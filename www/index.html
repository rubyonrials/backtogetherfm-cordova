<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta http-equiv="Content-Security-Policy" content="default-src * blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' blob:; style-src 'self' 'unsafe-inline'; media-src * blob:;">

    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <!-- For modern browsers - multi-size PNG -->
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <!-- For iOS - apple-touch-icon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <!-- For Windows Metro -->
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <style>
      @font-face {
        font-family: 'Runescape';
        src: url('runescape.ttf');
      }

      html, body {
        height: 100vh;
      }

      body {
        margin: 0;
        font-family: monospace;
      }

      #sunburst, #sunburst2 {
        position: absolute;
        width: 150vmax;
        height: 150vmax;
        top: 0;
        bottom: 0;
        margin: auto;
        border-radius: 50%;
      }
      #sunburst {
        animation: rotate 60s cubic-bezier(0.42, 0.3, 0.58, 0.7) infinite;
        z-index: -1;
      }
      #sunburst2 {
        animation: rotate 45s cubic-bezier(0.42, 0.3, 0.58, 0.7) infinite;
        z-index: -2;
      }

      @keyframes rotate {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      #title {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: Runescape;
        font-size: 26px;
        font-weight: bold;
        text-shadow: 1px 1px #00000059;
      }

      .blinking {
        animation: blink 1s steps(5, start) infinite;
      }

      @keyframes blink {
        to { visibility: hidden; }
      }

      #page {
        background: radial-gradient(circle at center, #fff7dd 33%, #101010 81%);
        background: #fff7dd;
        display: flex;
        justify-content: center;
        height: 100%;
        position: relative;
        overflow: hidden;
        align-items: center;
      }

      #content {
        text-align: center;
        justify-content: center;
        display: flex;
        flex-direction: column;
        flex: 1;
        max-width: 362px;
        margin: 25px;
        color: #2a303b;
        font-size: 15px;
      }

      #subtitle {
        margin: 6px 0 0;
      }

      a {
        font-size: 14px;
        text-decoration: none;
      }

      #radio-controls {
        display: flex;
        justify-content: center;
        margin-top: 25px;
      }

      .radio-control {
        font-size: 28px;
        padding: 0 25px;
        margin: 0 15px;
        user-select: none;
      }
      .radio-control:hover {cursor: pointer;}
      #play, #pause { width: 18px; }

      #loading {
        margin: 25px 0 0;
        min-height: 35px;
        text-align: center;
      }

      @keyframes glow {
        0% {
          color: #FF0000;
        }
        33% {
          color: #00B000;
        }
        66% {
          color: #0000FF;
        }
        100% {
          color: #FF0000;
        }
      }
      @keyframes wave {
        0% {
          transform: translateY(0);
        }
        25% {
          transform: translateY(4px);
        }
        50% {
          transform: translateY(0);
        }
        75% {
          transform: translateY(-4px);
        }
        100% {
          transform: translateY(0px);
        }
      }
      .t1 {
        display: inline-block;
        animation: wave 4s linear infinite -50ms, glow 4s linear infinite -50ms;
      }
      .t2 {
        display: inline-block;
        animation: wave 4s linear infinite -150ms, glow 4s linear infinite -100ms;
      }
      .t3 {
        display: inline-block;
        animation: wave 4s linear infinite -250ms, glow 4s linear infinite -150ms;
      }
      .t4 {
        display: inline-block;
        animation: wave 4s linear infinite -350ms, glow 4s linear infinite -200ms;
      }
      .t5 {
        display: inline-block;
        animation: wave 4s linear infinite -450ms, glow 4s linear infinite -250ms;
      }
      .t6 {
        display: inline-block;
        animation: wave 4s linear infinite -550ms, glow 4s linear infinite -300ms;
      }
      .t7 {
        display: inline-block;
        animation: wave 4s linear infinite -650ms, glow 4s linear infinite -350ms;
      }
      .t8 {
        display: inline-block;
        animation: wave 4s linear infinite -750ms, glow 4s linear infinite -400ms;
      }
      .t9 {
        display: inline-block;
        animation: wave 4s linear infinite -850ms, glow 4s linear infinite -450ms;
      }
      .t10 {
        display: inline-block;
        animation: wave 4s linear infinite -950ms, glow 4s linear infinite -500ms;
      }
      .t11 {
        display: inline-block;
        animation: wave 4s linear infinite -1050ms, glow 4s linear infinite -550ms;
      }
      .t12 {
        display: inline-block;
        animation: wave 4s linear infinite -1150ms, glow 4s linear infinite -600ms;
      }
      .t13 {
        display: inline-block;
        animation: wave 4s linear infinite -1250ms, glow 4s linear infinite -650ms;
      }
      .t14 {
        display: inline-block;
        animation: wave 4s linear infinite -1350ms, glow 4s linear infinite -700ms;
      }
      .t15 {
        display: inline-block;
        animation: wave 4s linear infinite -1450ms, glow 4s linear infinite -750ms;
      }
    </style>
  </head>

  <body>
    <div id='page'>
      <div id='sunburst'></div>
      <div id='sunburst2'></div>
      <div id='content'>
        <div id='title'>
            <span class='t1'>B</span>
            <span class='t2'>a</span>
            <span class='t3'>c</span>
            <span class='t4'>k</span>
            <span class='t5'>T</span>
            <span class='t6'>o</span>
            <span class='t7'>g</span>
            <span class='t8'>e</span>
            <span class='t9'>t</span>
            <span class='t10'>h</span>
            <span class='t11'>e</span>
            <span class='t12'>r</span>
            <span class='t13'>.</span>
            <span class='t14'>F</span>
            <span class='t15'>M</span>
        </div>
        <p id='subtitle'>
          Spatial silent disco.
        </p>

        <div id='radio-controls'>
          <div id='reconnect' class='radio-control'>&#x21BB;&#xFE0E;</div>
          <div id='play' class='radio-control' style='display:none;'>&#x23F5;&#xFE0E;</div>
          <div id='pause' class='radio-control' style='display:none;'>&#x23F8;&#xFE0E;</div>
        </div>


        <p id='loading' class='blinking'>Connecting...</p>
      </div>
    </div>

    <audio id="hls-audio" title='BackTogether.FM'></audio>
    <script type="text/javascript" src="cordova.js"></script>
    <script>
        const SERVER_URI = 'http://btos.fm';
        const RED = 'red';
        const BLUE = 'blue';
        const GREEN = 'green';
        const LIVE_COLOR_OPAQUE = '#ffb100ba';
        const LIVE_COLOR_TRANSPARENT = '#ffb10042';
        const AUDIO_PLAYER_ID = 'hls-audio';
        const CHANNEL_DIRECTORY = {
          red: {
            colorOpaque:'#dc322fba',
            colorTransparent:'#dc322f42',
            order: 1
          },
          green: {
            colorOpaque:'#429900ba',
            colorTransparent:'#45ff0042',
            order: 2
          },
          blue: {
            colorOpaque:'#268bd2ba',
            colorTransparent:'#268bd242',
            order: 3
          }
        }

        var currentChannel;
        var initializedRadioControls, userInitiatedPlayback = false;

        const getAudioPlayer = () => {
          return document.getElementById(AUDIO_PLAYER_ID);
        }

        const getStreamableChannels = async () => {
          const streamableChannels = await fetch(`${SERVER_URI}/getStreamableChannels`,
            {
              method: 'GET',
              headers: new Headers({ "ngrok-skip-browser-warning": "69420" })
            }
          )
            .then(response => response.json())
            .catch(error => throwError(error, 'Connection failed. Are you connected to BackTogether.FM WiFi?'));
          return Object.keys(streamableChannels);
        }

        const currentChannelIsPlaying = () => {
          return !getAudioPlayer().paused;
        }

        const stopAudioPlayback = () => {
          const audioPlayer = getAudioPlayer();
          audioPlayer.pause();
        }

        // In this function, we promisify callback-based APIs needed for initializing.
        // This allows us to wait until <audio> has actually started playing.
        const startAudioPlayback = async () => {
          if (!userInitiatedPlayback) userInitiatedPlayback = true;
          // Is current channel broadcasting?
          const audioPlayer = getAudioPlayer();

          const streamFilename = await fetch(`${SERVER_URI}/stream/${currentChannel}`,
            {
              method: 'POST',
              headers: new Headers({ "ngrok-skip-browser-warning": "69420" })
            }
          )
            .then(response => response.text())
            .catch(error => throwError(error, 'Connection failed. Are you connected to BackTogether.FM WiFi?'));
          const streamPath = `${SERVER_URI}/${streamFilename}`;

          if (audioPlayer.canPlayType('application/vnd.apple.mpegurl')) {
            const initializeNativeHls = () => {
              return new Promise((resolve, reject) => {
                audioPlayer.addEventListener('loadedmetadata', async () => {
                  await audioPlayer.play();
                  resolve();
                });
                audioPlayer.src = streamPath;
              });
            };

            await initializeNativeHls();
          } else {
            console.error('HLS.js is not supported in this browser.');
          }
        }

        // Called when new channel information is received from the broadcasting server
        const subscribe = async (channel) => {
          console.log('subscribe');

          var reinitialize = false;
          if (!currentChannel && initializedRadioControls) {
            currentChannel = channel;
            reinitialize = true;
          }

          if (userInitiatedPlayback && channel === currentChannel) {
            await startAudioPlayback();
          }

          updateRadioControls(reinitialize ? 'INITIALIZE' : null);
        }

        const unsubscribe = async (channel) => {
          console.log('unsubscribe');

          if (channel === currentChannel) {
            pause();

            const streamableChannels = await getStreamableChannels();
            if (streamableChannels?.length) {
              // Otherwise, let the normal updateRadioControls() in pause() display the proper message.
              displayLoading('IN_PROGRESS', 'Channel broadcast ended.');
            } else {
              displayLoading('IN_PROGRESS', 'Broadcast ended. Wait for the next event!');
            }
          } else {
            updateRadioControls();
          }
        }

        const pause = () => {
          stopAudioPlayback();
          updateRadioControls();
        }

        // channel: RED | BLUE | GREEN
        const playChannel = async (channel) => {
          await startAudioPlayback();
          updateRadioControls();
        }

        // type: 'NONE' | 'IN_PROGRESS' | 'ERROR' | 'WARNING'
        // message: String
        const displayLoading = (type, message = null) => {
          if (type === 'NONE') {
            document.getElementById("loading").style.display = 'none';
            document.getElementById("loading").innerHTML = '';
          } else {
            document.getElementById("loading").style.display = 'block';
            document.getElementById("loading").innerHTML = message;
          }

          if (type === 'IN_PROGRESS') {
            document.getElementById("loading").classList.add('blinking');
          } else {
            document.getElementById("loading").classList.remove('blinking');
          }

          if (type === 'ERROR') {
            document.getElementById("loading").style.color = 'red';
          } else {
            document.getElementById("loading").style.color = 'initial';
          }
        }

        // error: Error
        // customMessage: String
        const throwError = (error, customMessage) => {
          const fullErrorMessage = `${customMessage}\n\n ${error}`;
          displayLoading('ERROR', customMessage);
          throw new Error(fullErrorMessage);
        }

        // type: 'INITIALIZE' | null
        const updateRadioControls = async (type) => {
          if (!initializedRadioControls && type !== 'INITIALIZE') return;
          if (!initializedRadioControls) initializedRadioControls = true;

          const streamableChannels = await getStreamableChannels();
          console.log(`streamableChannels: ${streamableChannels}`);
          if (!streamableChannels?.length) {
            document.getElementById("radio-controls").style.display = 'none';
            document.getElementById("sunburst").style.background = 'none';
            document.getElementById("sunburst2").style.background = 'none';
            document.getElementById("page").style.background = '#fff7dd';
            displayLoading('ERROR', 'No current broadcast. Wait for the next event!');
            return;
          }

          displayLoading('NONE');

          var currentColorOpaque = CHANNEL_DIRECTORY[currentChannel].colorOpaque;
          var currentColorTransparent = CHANNEL_DIRECTORY[currentChannel].colorTransparent;

          /* if (!channelBackward && !channelForward) {
            currentColorOpaque = LIVE_COLOR_OPAQUE;
            currentColorTransparent = LIVE_COLOR_TRANSPARENT;
          } */

          if(currentChannelIsPlaying()) {
            document.getElementById("play").style.display = 'none';
            document.getElementById("pause").style.display = 'block';
            document.getElementById("page").style.background = `radial-gradient(circle at center, #f7f3ea 25%, ${currentColorOpaque} 81%)`;
            document.getElementById("sunburst").style.background = `repeating-conic-gradient( #ababab 0deg, ${currentColorTransparent} 1deg, #ababab 2deg, #ababab00 3deg)`;
            document.getElementById("sunburst2").style.background = `repeating-conic-gradient(#ababab00 0deg, ${currentChannel} 3deg)`;
          } else {
            if (streamableChannels.includes(currentChannel)) {
              document.getElementById("play").style.display = 'block';
              document.getElementById("reconnect").style.display = 'none';
            } else {
              document.getElementById("play").style.display = 'none';
              document.getElementById("reconnect").style.display = 'block';
            }
            document.getElementById("pause").style.display = 'none';
            document.getElementById("sunburst").style.background = 'none';
            document.getElementById("sunburst2").style.background = 'none';
          }

          document.getElementById("radio-controls").style.display = 'flex';
        }

        const restartConnection = async () => {
          const streamableChannels = await getStreamableChannels();
          currentChannel = streamableChannels[Math.floor(Math.random() * streamableChannels.length)];
          subscribe(currentChannel);
          updateRadioControls('INITIALIZE');
        }

        const initialize = async () => {
          document.getElementById("play").addEventListener("click", () => playChannel(currentChannel));
          document.getElementById("pause").addEventListener("click", pause);
          document.getElementById("reconnect").addEventListener("click", restartConnection);

          getAudioPlayer().addEventListener('ended', () => unsubscribe(currentChannel));
          restartConnection();
        }

        document.addEventListener('deviceready', onDeviceReady, false);
        function onDeviceReady() {
          var seenRSSIMap = {
            [ RED ]: [],
            [ GREEN ]: [],
            [ BLUE ]: []
          };
          var averageRSSIMap = {
            [ RED ]: null,
            [ GREEN ]: null,
            [ BLUE ]: null
          };

          function updateRange(beacon, color, major, minor) {
              if (beacon.major == major && beacon.minor == minor && beacon.rssi != 0) {
                  // Update seenRSSIMap
                  seenRSSIMap[color].push(beacon.rssi);
                  if (seenRSSIMap[color].length > 5) {
                      seenRSSIMap[color].shift();
                  }

                  // Update averageRSSIMap if 5 values

                  if (seenRSSIMap[color].length === 5) {
                    const sum = seenRSSIMap[color].reduce((acc, rssi) => acc + rssi, 0);
                    const average = sum / seenRSSIMap[color].length;
                    averageRSSIMap[color] = average;
                  }

                  // Update current channel if needed
                  let highestAverage = -Infinity; // Start with the lowest possible number
                  let closestChannel = null;
                  for (const color in averageRSSIMap) {
                      if (averageRSSIMap[color] !== null && averageRSSIMap[color] > highestAverage) {
                          highestAverage = averageRSSIMap[color];
                          closestChannel = color;
                      }
                  }

                  console.log("###");
                  console.log("###");
                  console.log("###");
                  console.log("NEW CHANNEL WOULD BE:", closestChannel);
                  console.log("###");
                  console.log("###");
                  console.log("###");
              }
          }

          var delegate = new cordova.plugins.locationManager.Delegate();
          <!-- delegate.didDetermineStateForRegion = function(pluginResult) { -->
          <!--     console.log('didDetermineStateForRegion:', pluginResult); -->
          <!-- }; -->
          <!-- delegate.didStartMonitoringForRegion = function(pluginResult) { -->
          <!--     console.log('didStartMonitoringForRegion:', pluginResult); -->
          <!-- }; -->
          delegate.didRangeBeaconsInRegion = function(pluginResult) {
              console.log('didRangeBeaconsInRegion:', pluginResult);
              pluginResult.beacons.forEach(function(beacon) {
                console.log('Detected iBeacon:' + beacon.uuid + ' RSSI:' + beacon.rssi + ' Major/Minor:' + beacon.major + beacon.minor);

                updateRange(beacon, RED, 0, 0);
                updateRange(beacon, GREEN, 1, 1);
                updateRange(beacon, BLUE, 2, 2);
                console.log(JSON.stringify(seenRSSIMap));
                console.log(JSON.stringify(averageRSSIMap));
              });
          };
          <!-- delegate.didEnterRegion = function(pluginResult) { -->
          <!--     console.log('didEnterRegion:', pluginResult); -->
          <!--     document.getElementById("page").style.background = 'green'; -->
          <!-- }; -->
          <!-- delegate.didExitRegion = function(pluginResult) { -->
          <!--     console.log('didExitRegion:', pluginResult); -->
          <!--     document.getElementById("page").style.background = 'red'; -->
          <!-- }; -->
          cordova.plugins.locationManager.setDelegate(delegate);
          cordova.plugins.locationManager.requestWhenInUseAuthorization();

          // Create a new region that uses the UUID of your beacon
          var masterUUID = '5ae549ce-f009-47c3-8727-49a686c72c15';
          var masterIdentifier = 'master-beacon-region';

          try {
            var masterRegion = new cordova.plugins.locationManager.BeaconRegion(masterIdentifier, masterUUID);

            cordova.plugins.locationManager.startMonitoringForRegion(masterRegion)
                .fail(function(e) { console.error(e); })
                .done();

            // Optionally start ranging for the region to determine proximity, not just entry/exit
            cordova.plugins.locationManager.startRangingBeaconsInRegion(masterRegion)
                .fail(function(e) { console.error(e); })
                .done();
          } catch (error) {
            console.error('beacon error', error.message);
            console.error(error.stack);
          }


          setTimeout(function() {
            initialize();
          }, 10000);

        }
    </script>
  </body>
</html>
